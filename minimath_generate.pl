#!/usr/bin/perl
use strict;
use warnings;
use feature qw(say);
use List::Util qw(min);
use List::MoreUtils qw(pairwise);

open OUT, ">minimath_generated.h" or die "Couldn't open the target header";

say OUT "// THIS IS AUTO-GENERATED BY $0. DO NOT EDIT BY HAND\n";

my @sizes = 2..5;

# the dot products, norms and basic arithmetic functions take the size as an
# argument. I'm assuming that the compiler will expand these out for each
# particular invocation
dotProducts();
norms();
vectorArithmetic();

foreach my $n(@sizes)
{
  matrixVectorSym($n);
  foreach my $m (@sizes){ matrixVectorGen($n, $m) }
}

close OUT;





sub dotProducts
{
  say OUT <<EOC;
static inline double dot_vec(int n, const double* restrict a, const double* restrict b)
{
  double dot = 0.0;
  for(int i=0; i<n; i++)
    dot += a[i]*b[i];
  return dot;
}
EOC
}

sub norms
{
  say OUT <<EOC;
static inline double norm2_vec(int n, const double* restrict a)
{
  double dot = 0.0;
  for(int i=0; i<$n; i++)
    dot += a[i]*a[i];
  return dot;
}
EOC
}

sub vectorArithmetic
{
  my $vout = <<EOC;
// a + b
static inline void add_vec_vout(int n, const double* restrict a, const double* restrict b, double* restrict vout)
{
  for(int i=0; i<n; i++)
    vout[i] = a[i] + b[i];
}
// a - b
static inline void sub_vec_vout(int n, const double* restrict a, const double* restrict b, double* restrict vout)
{
  for(int i=0; i<n; i++)
    vout[i] = a[i] - b[i];
}

EOC

  say OUT $vout;

  my $arg0 = _getFirstDataArg($vout);
  say OUT _makeInplace($vout, $n, $n, $arg0);
  say OUT _makeVaccum ($vout);
}

sub matrixVectorSym
{
  my $n = shift;

  my $vout = <<EOC;
// $n-vector by symmetric ${n}x$n
static inline void mul_vec${n}_sym$n${n}_vout(const double* restrict v, const double* restrict s, double* restrict vout)
{
EOC

  # I now have the header, opening brace. Writing each row element output
  my %isymHash = (next => 0);

  for my $i(0..$n-1)
  {
    my $isym_row = _getSymmetricIndices_row(\%isymHash, $i, $n);
    my @cols = 0..$n-1;

    our ($a,$b);
    my @sum_components = pairwise {"s[$a]*v[$b]"} @$isym_row, @cols;
    $vout .= "  vout[$i] = " . join(' + ', @sum_components) . ";\n";
  }

  $vout .= "}\n";


  print OUT _multiplicationVersions($vout, $n, $n);
}


sub matrixVectorGen
{
  my $n = shift;
  my $m = shift;

  # I now make NxM matrix-vector multiplication. I describe matrices math-style
  # with the number of rows first (NxM has N rows, M columns). I store the
  # matrices row-first and treat vectors as row-vectors. Thus these functons
  # compute v*A where v is the row vector and A is the NxM matrix

  my $vout = <<EOC;
// $n-vector by ${n}x$m matrix multiplication
static inline void mul_vec${n}_gen$n${m}_vout(const double* restrict v, const double* restrict m, double* restrict vout)
{
EOC

  # I now have the header, opening brace. Writing each row element output
  for my $i(0..$m-1)
  {
    my @js = 0..$n-1;
    my @im = map {$i + $_*$m} @js;

    our ($a,$b);
    my @sum_components = pairwise {"m[$a]*v[$b]"} @im, @js;
    $vout .= "  vout[$i] = " . join(' + ', @sum_components) . ";\n";
  }

  $vout .= "}\n";
  print OUT _multiplicationVersions($vout, $m, $n);


# now the transposed version
  $vout = <<EOC;
// $n-vector by ${m}x$n-transposed matrix multiplication
static inline void mul_vec${n}_gen$m${n}t_vout(const double* restrict v, const double* restrict mt, double* restrict vout)
{
EOC

  # I now have the header, opening brace. Writing each row element output
  for my $i(0..$m-1)
  {
    my @js = 0..$n-1;
    my @im = map {$i*$n + $_} @js;

    our ($a,$b);
    my @sum_components = pairwise {"mt[$a]*v[$b]"} @im, @js;
    $vout .= "  vout[$i] = " . join(' + ', @sum_components) . ";\n";
  }

  $vout .= "}\n";
  print OUT _multiplicationVersions($vout, $m,$n);
}


sub _multiplicationVersions
{
  my $vout = shift;
  my $n    = shift;
  my $m    = shift;

  my $arg0 = _getFirstDataArg($vout);

  my $funcs = $vout . "\n";
  $funcs .= _makeInplace($vout, $n, $m, $arg0, 'withtmp') . "\n";
  $funcs .= _makeVaccum ($vout) . "\n";
  $funcs .= _makeScaled ($funcs) . "\n";

  return $funcs;
}

sub _getSymmetricIndices_row
{
  my $hash     = shift;
  my $i        = shift;
  my $n        = shift;

  my @isym;
  for my $j (0..$n-1)
  {
    my $key = join(',', sort($i,$j));
    if( !exists $hash->{$key} )
    {
      $hash->{$key} = $hash->{next};
      $hash->{next}++;
    }

    push @isym, $hash->{$key};
  }

  return \@isym;
}

sub _getFirstDataArg
{
  my $v = shift;

  # I have a string with a bunch of functions. Get the first argument. I ASSUME
  # THE FIRST ARGUMENT HAS THE SAME NAME IN ALL OF THESE
  my ($arg0) = $v =~ m/^static inline.*\(.*?double\* restrict ([a-z0-9_]+),/m or die "Couldn't recognize function in '$v'";
  return $arg0;
}

sub _makeInplace
{
  my $v       = shift;
  my $n       = shift;
  my $m       = shift;
  my $arg0    = shift;
  my $withtmp = shift;

  # rename functions
  $v =~ s/_vout//gm;

  # get rid of the 'vout argument'
  $v =~ s/, double\* restrict vout//gm;

  # un-const first argument
  $v =~ s/^(static inline.*\()const (double.*)$/$1$2/gm;

  # use the first argument instead of vout
  $v =~ s/vout/$arg0/gm;

  # if we're asked to make some temporary variables, do it
  if($withtmp)
  {
    my $nt = min($n-1,$m);

    # use the temporaries instead of the main variable when possible
    foreach my $t(0..$nt-1)
    {
      $v =~ s/(=.*)${arg0}\[$t\]/$1t[$t]/mg;
    }

    # define the temporaries. I need one fewer than n
    my $tempDef = "  double t[$nt] = {" . join(', ', map {"${arg0}[$_]"} 0..$nt-1) . "};";
    $v =~ s/^{$/{\n$tempDef/mg;
  }

  return $v;
}

sub _makeVaccum
{
  my $v    = shift;

  # rename functions
  $v =~ s/_vout/_vaccum/gm;

  # vout -> vaccum
  $v =~ s/vout/vaccum/gm;

  # make sure we accumulate
  $v =~ s/(vaccum\[.*?\]\s*)=/$1+=/gm;

  return $v;
}

sub _makeScaled
{
  my $f = shift;

  # rename functions
  $f =~ s/^(static inline .*)(\s*\()/${1}_scaled$2/gm;

  # add the scale argument
  $f =~ s/^(static inline .*)\)$/$1, double scale)/gm;

  # apply the scaling
  $f =~ s/(.*=\s*)([^{}]*?);$/${1}scale * ($2);/gm;

  return $f;
}










__END__







writeMatrixVectorMul



__END__

// general Nx3 matrix by symmetrix 3x3, written into a new Nx3
static inline void mul_genN3_sym33_vout(const double* restrict v, const double* restrict s, double* restrict vout, int n)
{
  for(int i=0; i<n; i++)
    mul_vec3_sym33_vout(v + 3*i, s, vout + 3*i);
}

// general Nx3 matrix by symmetrix 3x3, accumulated into a given Nx3
static inline void mul_genN3_sym33_vaccum(const double* restrict v, const double* restrict s, double* restrict vaccum, int n)
{
  for(int i=0; i<n; i++)
    mul_vec3_sym33_vaccum(v + 3*i, s, vaccum + 3*i);
}

// general Nx3 matrix by symmetrix 3x3, written back into the Nx3
static inline void mul_genN3_sym33(double* restrict v, const double* restrict s, int n)
{
  for(int i=0; i<n; i++)
    mul_vec3_sym33(v + 3*i, s);
}



// general Nx3 matrix by general 3x3, written back into the Nx3
static inline void mul_genN3_gen33(double* restrict v, const double* restrict m, int n)
{
  for(int i=0; i<n; i++)
    mul_vec3_gen33(v + 3*i, m);
}

// general Nx3 matrix by general 3x3 (transpose input), written back into the Nx3
static inline void mul_genN3_gen33t(double* restrict v, const double* restrict mt, int n)
{
  for(int i=0; i<n; i++)
    mul_vec3_gen33t(v + 3*i, mt);
}

// general Nx3 matrix by general 3x3, written into a new Nx3
static inline void mul_genN3_gen33_vout(const double* restrict v, const double* restrict m, double* restrict mout, int n)
{
  for(int i=0; i<n; i++)
    mul_vec3_gen33_vout(v + 3*i, m, mout + 3*i);
}

// general Nx3 matrix by general 3x3 (transpose input), written into a new Nx3
static inline void mul_genN3_gen33t_vout(const double* restrict v, const double* restrict mt, double* restrict mout, int n)
{
  for(int i=0; i<n; i++)
    mul_vec3_gen33t_vout(v + 3*i, mt, mout + 3*i);
}

// general Nx3 matrix by general 3x3, accumulated into a Nx3
static inline void mul_genN3_gen33_vaccum(const double* restrict v, const double* restrict m, double* restrict maccum, int n)
{
  for(int i=0; i<n; i++)
    mul_vec3_gen33_vaccum(v + 3*i, m, maccum + 3*i);
}

// general Nx3 matrix by general 3x3 (transpose input), accumulated into a Nx3
static inline void mul_genN3_gen33t_vaccum(const double* restrict v, const double* restrict mt, double* restrict maccum, int n)
{
  for(int i=0; i<n; i++)
    mul_vec3_gen33t_vaccum(v + 3*i, mt, maccum + 3*i);
}

// takes in 2 Nx3 matrices. Computes the upper triangle of m0 * transpose(m1). The output is assumed to be symmetric
static inline void mul_genN3_genN3t_intosym_accum(const double* restrict m0, const double* restrict m1, double* restrict saccum, int n)
{
  // I compute the output as a bunch of inner products
  int iout = 0;
  for(int i=0; i<n; i++)
    for(int j=i; j<n; j++)
    {
      for(int irow = 0; irow<3; irow++)
        saccum[iout] += m0[irow + i*3]*m1[irow + j*3];
      iout++;
    }
}









